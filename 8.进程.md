# 进程

## 一、计算机的组成（冯诺依曼结构）

### 1-1：五大单元：输入单元，输出单元，存储器，CPU（运算器 + 控制器）

1.输入单元：键盘，话筒，摄像头等等

2.输出单元：显示器，喇叭，打印机等等

3.存储器：内存，（RAM）

4.CPU：负责解析指令，执行指令。

![image-20240110203833731](pic\image-20240110203833731.png)

```c
#include<stdio.h>

int main(int argc,char * argv[])
{
	printf("the input is\n");
	return 0;
}
```

2.这5几个单元是如何工作的：我们执行上面程序，首先会把程序加载到内中，然后CPU去执行对应的指令，然后遇到了scanf，就会等待输入设备的读取，输入完成之后，在执行printf，写入到显存，然后让显示驱动器去解析显存的内容。

### 1-2：存储分级

<img src="pic\image-20240110144656639.png" alt="image-20240110144656639" style="zoom:50%;" />

1.距离CPU越近速度就越快，但是价格就越贵

### 1-3：CPU不和外设的数据直接进行交互

1.外设的速度比较慢，如果你每次都要等待外设数据交互完才可以，那么就得会慢，但是如果说通过内存去读取外设数据，CPU和内存交互，速度就会提高。（如果我们执行程序是从磁盘里面读取，就会很慢很慢）

2.我们在外设数据弄到内存的时候，让CPU去执行其他的指令，此时速度就上去了。（这一步是由操作系统来做的 ）

3.在我们需要输入设备数据的时候我们可以让CPU先去处理其他事情，等等我们需要的数据ok了之后在回来执行当前任务。

### 1-4：你在vx发个消息给你的朋友，数据是如何流动的

1.先从键盘（输入设备）读取数据到内存中，然后通过网卡（输出设备）把数据发送出去，经过一系列的网络到达对方的网卡，对方的电脑从网卡中读取数据，显示到屏幕中。

![image-20240110210131345](pic\image-20240110210131345.png)

### 1-5：你把文件通过到qq发送给你的朋友



## 一、操作系统

### 1-1：什么是操作系统

1.进行软件和硬件管理的软件 

### 1-2：为什么有操作系统

1.操作系统将软件和硬件资源管理好，给用户提供良好（稳定，高效，完全）的使用环境（目的）

2.就要好比说：你要执行一个程序，我们要把程序加载到内存中，那么这个程序加载到哪里，需要多大的内存，什么时候加载（大量数据的时候），在有就是你要保持文件，文件保持在哪里，需要多大的磁盘，这些都是由os来做的。

![image-20240110210539837](pic\image-20240110210539837.png)

3.通过以上手段都是为了给用户提供良好的（稳定，高效，完全）使用环境（目的）。

### 1-3：怎么办

1.通过数据进行对软件和硬件的管理

2.先描述，在组织

3.通过对硬件设备的属性等等进行描述，进而提供给上层用户接口，用户通过调用接口（也就是系统调用）即可操作设备

#### 1-3-1：学校是如何管理起来的？

1.你学校的校长可能连面都见不到，如何对你进行管理的？？？

2.举个例子：校长要开除一个学生，校长不可能说无缘无故就开除一个学生，需要根据一个学生的表现来确定这个学生是不是真的要开除，也就是说校长是根据这个学生的数据来确定对这个学生是不是需要开除。（os也是如果，就比如你要把文件保存到磁盘，那么你就要知道磁盘的数据（剩下的空间大小，哪里有空间等等））

3.由于校长需要根据学生的数据进行管理，所以说我们就需要把学生的数据给描述出来（比如：成绩，学分，德育分等等），同样我们对磁盘也就需要描述的数据出来

```c
struct SSD1
{
    size_t size;
    size_t start;
    size_t end;
    //.....
}
```

4.校长把学生的数据统统弄execl表中，此时根据这个学生的数据确定要开除了，这个时候校长就会把这个学生从表格中删除，并且此时让这个学生滚出学校（保存文件到磁盘也是一个道理的，我们确定了需要的磁盘大小和位置，我们就要把内容进行写入到磁盘中）

### 1-4：操作系统的构成

1.浅浅的聊一下Linux下一切皆文件的思想

### ![](C:\Users\old\AppData\Roaming\Typora\typora-user-images\image-20240114201722434.png)

### 1-5：系统调用是什么

1.开发人员需要通过os去访问数据

2.由于os不信任用户，所以os就提供了系统调用

3.用于访问操作系统的数据或者是访问硬件级别的操作，就需要通过系统调用。

#### 1-5-1：系统调用的使用和库函数的关系

1.由于系统调用会比较难用，所以弄了shell出来了，还有标准库

## 二、进程

### 2-1：硬件层面的进程

1.我们从硬件层面上来看所谓的进程便是把程序搬运到内存的一块区域，然后CPU寻址执行程序的内存

![image-20240111164352062](pic\image-20240111164352062.png)

2.对于单片机在没有移植操作系统的情况下，只有一个进程不需要进程管理什么的。但是对于电脑来说有很多的进程，假设到单核的情况那么我们就需要有合理的调度进程。

![image-20240111164847171](pic\image-20240111164847171.png)

### 2-2：os层面的进程

1.由于会出现多个进程的情况，所以我们需要对进程进行管理，在前面我们说到要对软件/硬件进行管理，我们就需要对其进行描述和组织

#### 2-2-1：在操作系统中是如何对其进行描述和组织的？

1.我们需要进行的各种属性，比如进程的ID，在内存哪一块区域，状态等等

```c
struct 
{
	//标识符：描述本进程的唯一标识符 pid（process id）
	//代码地址&&数据地址
	//状态
	//优先级
	//链接字段
}
```

2.接着把这些结构体通过特殊的数据结构存储器（较为老的Linux内核时数组，新的内核是链表）

```c
struct *PCB[64];/* 这里为何是struct * PCB ,而不是struct PCB */
```

![image-20240111171121837](pic\image-20240111171121837.png)



3.接着我们需要提供进程的操作函数，比如运行，停止等等

```c
void sleep_on(struct task **p); /* 睡眠 */
void sched(void)		/* 调度出合适进程 */
```

4.通过上面的步骤我们就完成了对进程的描述和组织，接下来我们就可以对进程进行管理了，比如某个进程的优先级高，那就先让他执行。或者CPU正在指向的进程需要读取磁盘资源，那就调度出来合适的进程替换掉当前进程。

### 2-3：所谓的动态是什么意思 

1.在很多教程中都有进程是动态的程序，这句话是什么意思？

![image-20240111171556342](pic\image-20240111171556342.png)



### 2-4：获取进程的信息

#### 2-4-1：ps命令

```shell
ps -ajx / ps -aux
#这俩个命令用于查看系统当前正在运行的程序一般配合grep一起使用
ps -ajx | grep 目标进程
```

#### 2-4-2：getpid、getppid()

```c
pid_t getpid(void);/* 获取调用该函数进程的pid */
pid_t getppid(void);/* 获取调用该函数进程的ppid(父进程的id) */
```

1.什么是父进程：进程A创造了进程B，此时进程A就是进程B的父进程（这样说有点抽象，我们后面说fork的时候来详细说说）

```c
#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>


int main()
{
	printf("my pid is %d my ppid is %d\n",getpid(),getppid());
	return 0;
}

//我们通过终端编译启动该进程，就会发现pid一直在变化，但是ppid没有变化，这是因为你通过终端执行这个代码，那么这个进程就属于终端的子进程，所以这个进程的父进程是终端
```

2.getpid做了写什么事情：通过系统调用，进入到操作系统，把其中的数据从内核搬运到用户中去。

#### 2-4-3：通过文件去查看进程信息

1.在/proc目录下那些数字作为名字的目录便是保存进程信息用的目录，其中名字的数字表示的是进程的PID

2.我们可以通过/proc/xxx/exe找到可执行程序（执行一个程序之后，去查看是否有 && 我把磁盘文件干掉了，正在执行的程序会怎么样）

3.我们可以通过/proc/xxx/cwd找到进程的工作目录（默认的情况下就是你启动一个进程所在的路径），通过chdir去改变进程的工作目录

```c
fopen("./test","r+");/* 是如何找到默认路径的？显而易见就是通过进程的工作目录找到的 */
```

```c
#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>


int main()
{
	chdir("/home/yjt/biji");
	FILE* p = fopen("./test","w");
	if(p == NULL)
		return -1;
	fclose(p);
	while(1)
	{
		printf("my pid is %d my ppid is %d\n",getpid(),getppid());
		sleep(1);
	}
	return 0;
}
```

### 2-5：fork

```c
pid_t fork(void);
/* 
	role: create a new process by duplicating the calling process
	parm: void
	ret: On success, the PID of the child process is returned in the parent, and 0 is returned in the child.  On failure, -1 is returned in the  parent,no child process is created, and errno is set appropriately.

*/
```

1.验证fork能创建出来子进程

```c
#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>


int main()
{
	printf("my id is %d\n",getpid());


	fork();


	printf("my id is %d\n",getpid());
	return 0;
}

/* 执行往完会发现fork后面的代码被执行了俩边，这也就是说明了fork会多创建一个进程出来，而被创建出来的进程就是子进程了 */
```

2.让fork实现分流：前面说到fork子进程返回0，父进程返回值子进程的id那么我们就可以通过这个点来实行俩个进程的分流

```c
//实例代码
pid_t id = fork();
if(id < 0)
    return 1;
else if(id == 0)
{
    while(1)
    {
    	printf("I'm child ,id is %d\n ret is %d\n",getpid(),id);
       	sleep(1); 
    }
}
else
{
    while(1)
    {
		printf("I'm perant,id is %d\n,ret is %d\n",getpid(),id);
       	sleep(1);
    }
    
}    


/* fork干了些什么事情，为什么又俩个返回值，为什么给父进程返回子进程的pid，子进程返回0 */
/* 为什么返回值不同？？？ */
/* 为什么同一个变量接受但是又是不同的值？ */
```

4.fork做了写什么事情？

**创建子进程的pcb**

![image-20240112191047569](pic\image-20240112191047569.png)





## 三、进程状态

 1.运行，停止，就绪，挂起，初始化

### 2-1：运行状态

1.里面有一个运行队列，程序执行起来之后就会把该进程的PCB写入的运行队列中

### 2-2：阻塞状态

1.我们的代码一定会访问系统的外部设备（比如键盘，IO），就如果说调用scanf，如果我们一直不输入，就会停止，不会继续执行下去。 

2.在对设备进行管理的时候，也要对设备进行描述。通过访问设备信息去对访问和读写的操作，假如此时我们要去

3.从设备等待队列到就绪队列，每一个设备都会一个队列 

4.上层到的现象就是程序卡住了，也就是没在就绪队列，没把发把进程PCB调度出来 



### 2-3：挂起状态

1.在内存不足的情况，某个进程在阻塞队列的时候，该进程的PCB会被写入到磁盘，也就是挂起

2.这会针对全部的阻塞进程。

3.写入磁盘也不是随便写的，写入一个叫swap的分区中（不要把swap分区弄太大）。





## 四、Linux下的进程状态

### 4-1：状态的描述

1.前台进程：会把bash占用的进程

```c
static const char * task_state_array[] = {
  
    "R(running)",  //也就是运行状态
    "S(sleeping)",	//休眠状态，也就是操作系统中的阻塞状态，浅度休眠,需要等待资源
    "D(disk sleep)",	//深度休眠，专门针对磁盘设计的，针对于磁盘的IO，需要大量的IO的时候就要进行深度休眠，深度休眠的状态不可被杀死
    "T(stopped)",		//暂停，SIGSTOP,访问暂时不可访问的状态
    "t(tracing stop)",	//追踪暂停状态，debug状态
    "Z(zmbie)",			//僵尸进程，表示进程执行结束，但是PCB没有被释放。收尸问题？
    "X(dead)"			//死亡状态
    
    //+表示前台进程
};
```

1.进程状态：便是task_struct里面一个字段，所谓的状态变化就是改变PCB里面的状态字段。

2.在操作系统中是怎么样的？

![image-20240116184603872](pic\image-20240116184603872.png)

​     

### 4-2：孤儿进程

父进程先消亡，但是子进程还没消亡，这样就会产生孤儿进程，此时这个子进程被init（1号进程）收养

## 五、优先级

### 5-1：是什么，为什么，怎么做需要优先级

1.为什么需要优先级：本质就是资源不足，比如在食堂只有几个窗口，但是需要用餐的人数远大于窗口， 

2.是什么：得到资源的顺序

3.怎么做：通过调度算法和PCB优先级字段描述

4.nice值：一个进程的优先级是由于nice（可以为负数）值和优先级数值决定，prio = prio（old） +nice，一般情况下，prio都是80，进程的优先级范围是60到99，也就是nice最多也就是19到-20

5.如果一个进程的优先级过高，导致优先级低的进程调度不到，

6.获取进程优先级的系统调用

```c
int getpriority(int which,int who);//获取
int setpriority(int which,int who);//设置
```

7.竞争性、独立性、并行、并发的概念



top + r

## 六、进程切换和命令行参数

###   6-1：进程是如何切换的

1.我们要知道cpu是如何进行取值执行的：pc指针指向目标目标，然后一系列寄存器保存的现在正在运算的指令。

2.那么我们要进行进程切换就需要把这些寄存器的数据保存下来，写入到task_struct中去，称为保护现场，要进行切换回来的时候就把task_struct里面保存寄存器的数据写入到cpu寄存器中去

![image-20240116190251876](pic\image-20240116190251876.png)

###  6-2：现代Linux的进程切换

1.关于active和expired指针

2.如何调度和如何进行抢占

3.bitmap

4.nr_acvtive

 

## 七、命令行参数

#### 7-1：main函数的参数

```c
int main(int argc,char * argv[]);

/* 我们尝试把命令行参数打印出来看看 */
int main(int argc,char * argv[])
{
	for(int i = 0;i < argc,i++)
    {
		printf("%d %s\n",i,argv[i]);
    }
}

/* 看看执行完的结果 */
./main -h -fasdf -fdasf

    
/* 通过空格进行分割，./main是argv[0]，剩下的以此类推 */
/* argc表示的是你传入参数的个数 */
```

1.为什么要这么做：给定一个程序一些参数，主要是根据参数执行不同功能

## 八、环境变量

1.我们来思考个文件：为什么执行系统的指令不需要./，我们直接的指令却需要？

2.我们要执行一个命令，所以需要找到这个命令对吧，./表示在当前目录下找到他，而ls或者pwd这种命令显然就是有默认的搜索路径

3.决定这个默认的搜索路径的就是环境变量。（PATH变量）

4.我们需要添加我们的文件目录上去就可以了。





1.Linux的PATH是搜索可执行文件的路径

2.HOME / PWD 命令

3.env：查看环境变量的指令



### 8-1：获取环境变量

4.getenv函数(获取环境变量)



### 8-2：程序的环境变量

5.main函数的第三个参数，char* env[]  

```c
int main(int argc,char * argv[],char * env[])
{
	for(int i = 0;env[i];i++)
		printf("%s\n",env[i]);
	
	return 0;
}
```

6.环境变量从哪里来的？：在用户的目录下有一个.bash_profile（Centos是这个文件Ubuntu似乎是.bashrc）文件，系统会读取文件进行配置文件，进而我们的命令行就有了环境变量。

7.我们执行起来的程序的环境变量就是通过复制bash的环境变量来的。

8.手动添加环境变量export + 变量名字，但是可以配置的环境变量是在内存里面的，没有修改配置文件，所以一机，就会消失，我们也需要修改配置文件.bash_profile



9.environ，用于指向全局变量的指针

9.本地变量和环境变量的区别，本地变量之会在bash内部有效，不会被子进程继承下去，环境变量会被继承下去，echo是如何读取本地变量，因为echo是内建命令，不需要创建子进程，shell命令行的一个函数。就是俩个进程不同的地址空间。echo会不会创建出子进程？？？为什么不会？

10.set可以查看本地变量和环境变量

## 九、 程序地址空间

### 9-1：程序的内存基本发布

1.我们都知道，一个进程内存区域大体有：堆区、栈区、未初始化全局数据区、已经初始化全局数据、字符常量区、代码段

2.那么具体是如何排布呢？

```c
#include<stdio.h>
#include<stdlib.h>
int init_global;
int uinit_global = 0;

int main(int argc,char * argv[])
{
	char * arr = "hello world";
	char * tmp = (char*)malloc(100);
	printf("代码段的地址 %p\n",main);
	printf("堆区的地址 %p\n",tmp);
	printf("栈区的地址 %p\n",&arr);
	printf("初始化全局区的地址 %p\n",&init_global);
	printf("未初始化全局去的地址 %p\n",&uinit_global);
	printf("字符常量区的地址 %p\n",arr);
	

	return 0;
}
```

3.通过上面的代码我们可以知道其地址空间大概入下图：栈向下生成，堆向上生长

![图1](D:\笔记\Linux\图1.png)

**向下申请，向上使用**：对于数组结构体都是这样的

**int b; &b**：这个是取得的是哪个字节的地址

**static修饰的变量在哪里呢**：全局区

**栈区之上还有命令行参数**：进行一手查看操作

 4.重新理解地址

```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>


int main(int argc,char * argv[])
{

	pid_t pid = fork();
	if(pid == 0)
	{
		pid = 1;
		printf("the perant pid is %d the ptr is %p\n",pid,&pid);
	}
	else if(pid > 0)
	{
		printf("the child pid is %d the ptr is %p\n",pid,&pid);
	}

	return 0;
}

/* 通过上面的代码我们会发现：子进程和父进程pid变量的地址是一样
	，但是数值确实不一样的，这是为什么呢？
    这里我们就要引入类外一个概念：虚拟内存*/

```

### 9-2：虚拟内存和物理内存

1.基于前面的实验，我们已经得出c/c++程序看到的地址不是实际的物理地址，而是虚拟地址

2.那么我们就要来解释一下，物理地址和虚拟的地址是如何关联起来的，以及俩个进程的pid变量的地址为什么会一样

**物理地址和虚拟的地址是如何关联起来的**：

每一个进程都一个独立的页表，虚拟内存通过页表映射关系到物理内存上面，不同的进程给到映射不同，即使虚拟地址是一样的

![图2](D:\笔记\Linux\图2.png)

**进程的pid变量的地址为什么会一样**：这个就更好解释了，子进程会复制父进程的内存，虚拟地址一样是因为父进程直接吧虚拟地址拷贝给了子进程

**为什么修改后会不一样**：写时拷贝的技术



1.写时拷贝在哪里拷贝：哪个进程对数据写入，哪个进程拷贝

2.谁来做：操作系统

3.影不影响语言的使用：不影响

### 9-3：在进程中的虚拟内存

1.进程PCB中会有一个结构体去描述当前进程的虚拟内存的情况。

```c
struct mmap
{
	long long heap_start;
    long long heap_end;
	long long stack_start;
    long long stack_end;
	long long global_start;
    long long global_end;
	long long const_start;
    long long const_end;
    long long code_start;
    long long code_end;
}
```

2.域区划分便是对每一个区域从起始地址到结束地址的描述

**在计算机中什么是地址空间？**：

**C/C++的变量是什么意思**：变量名是给开发人员看的，实际上都会被转化为地址。

### 9-4：为什么要有虚拟地址映射操作

1.把进程管理和内存管理独立开，实现代码的解耦

2.其次就是为了对用户在没有权限的空间和只读内存区域的时候进行拦截：页表有一个权限字段，用于表示对该内存的权限是只读，还是读写都有

3.进程和页表是如何进行对齐起来的：cpu有一个CR3寄存器，当进程切换的时候，会把该进程的页表写入到该寄存器中。

4.更加合理的加载资源，就比如说你要指向虚拟的地址某一条对应的指令/数据，我们可以先查看页表中是否存在，如果没有那么就产生一个缺页中断，让程序/数据加载进来。



